/**
 * Cart Service
 *
 * Business logic for cart operations:
 * - Get or create cart for user
 * - Add items to cart
 * - Update item quantities
 * - Remove items from cart
 *
 * Enforces business rules from PRD (BR-2.x).
 */

import type { Types } from 'mongoose';
import { Types as MongooseTypes } from 'mongoose';

import type { Cart } from '@/domain/entities';
import {
  CartModel,
  ItemModel,
  MAX_CART_ITEMS,
  MAX_ITEM_QUANTITY,
  MIN_ITEM_QUANTITY,
} from '@/lib/db/models';
import connectDB from '@/lib/db/mongoose';

// ============================================================================
// Types
// ============================================================================

export interface AddItemToCartInput {
  /** Item ID from catalog */
  itemId: string;

  /** Quantity to add (default: 1) */
  quantity?: number;
}

// ============================================================================
// Error Classes
// ============================================================================

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class ItemNotFoundError extends Error {
  constructor(itemId: string) {
    super(`Item not found: ${itemId}`);
    this.name = 'ItemNotFoundError';
  }
}

export class CartLimitError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CartLimitError';
  }
}

// ============================================================================
// Service Functions
// ============================================================================

/**
 * Helper to convert userId string to ObjectId for MongoDB queries.
 * NextAuth returns userId as string, but MongoDB stores ObjectId.
 */
function toObjectId(userId: string | Types.ObjectId): Types.ObjectId {
  return typeof userId === 'string'
    ? new MongooseTypes.ObjectId(userId)
    : userId;
}

/**
 * Get cart for user (or create if doesn't exist)
 *
 * Cart ID is always the same as userId for simplicity.
 * Each user has exactly one cart.
 *
 * Business Rules:
 * - BR-2.3: Cart associated with authenticated user
 *
 * @param userId - User ID (ObjectId or string)
 * @returns User's cart
 */
export async function getCartForUser(
  userId: string | Types.ObjectId
): Promise<Cart> {
  await connectDB();

  try {
    // Convert string userId to ObjectId for MongoDB query
    const userIdQuery = toObjectId(userId);

    // Try to find existing cart by userId
    let cart = await CartModel.findOne({ userId: userIdQuery }).lean().exec();

    if (!cart) {
      // Create new cart if doesn't exist
      // Cart _id will be auto-generated by MongoDB, but userId is the lookup key
      const newCart = new CartModel({
        userId: userIdQuery,
        items: [],
      });
      cart = await newCart.save();
    }

    return mapCartToDto(cart);
  } catch (error) {
    console.error('Error fetching cart for user:', userId, error);
    throw new Error('Failed to fetch cart');
  }
}

/**
 * Add item to cart
 *
 * Business Rules:
 * - BR-2.2: Quantity per item: min 1, max 999
 * - BR-2.3: Cart associated with authenticated user
 * - Max 50 items per cart
 *
 * @param userId - User ID (ObjectId or string)
 * @param input - Item and quantity
 * @returns Updated cart
 */
export async function addItemToCart(
  userId: string | Types.ObjectId,
  input: AddItemToCartInput
): Promise<Cart> {
  await connectDB();

  const quantity = input.quantity ?? 1;

  // Validate quantity (BR-2.2)
  if (quantity < MIN_ITEM_QUANTITY || quantity > MAX_ITEM_QUANTITY) {
    throw new ValidationError(
      `Quantity must be between ${MIN_ITEM_QUANTITY} and ${MAX_ITEM_QUANTITY}`
    );
  }

  try {
    // Verify item exists
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const item = (await ItemModel.findById(input.itemId).lean().exec()) as any;

    if (!item) {
      console.error(`[addItemToCart] Item not found with ID: ${input.itemId}`);
      throw new ItemNotFoundError(input.itemId);
    }

    // Convert string userId to ObjectId for MongoDB query
    const userIdQuery = toObjectId(userId);

    // Find or create cart
    let cart = await CartModel.findOne({ userId: userIdQuery }).exec();

    if (!cart) {
      cart = new CartModel({
        userId: userIdQuery,
        items: [],
      });
    }

    // Check if item already in cart
    const existingItemIndex = cart.items.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (cartItem: any) => cartItem.itemId?.toString() === input.itemId
    );

    if (existingItemIndex >= 0) {
      // Update quantity of existing item
      const newQuantity = cart.items[existingItemIndex].quantity + quantity;

      if (newQuantity > MAX_ITEM_QUANTITY) {
        throw new ValidationError(
          `Total quantity for this item would exceed maximum of ${MAX_ITEM_QUANTITY}`
        );
      }

      cart.items[existingItemIndex].quantity = newQuantity;
    } else {
      // Add as new item
      if (cart.items.length >= MAX_CART_ITEMS) {
        throw new CartLimitError(
          `Cart cannot contain more than ${MAX_CART_ITEMS} different items`
        );
      }

      // Push to cart items (using 'any' to bypass type mismatch between schema and document type)
      // The schema uses 'name' but CartItemDocument type uses 'itemName' after mapping
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (cart.items as any).push({
        itemId: input.itemId,
        name: item.name,
        unitPrice: item.estimatedPrice,
        quantity,
        addedAt: new Date(),
      });
    }

    const updatedCart = await cart.save();
    return mapCartToDto(updatedCart);
  } catch (error) {
    if (
      error instanceof ItemNotFoundError ||
      error instanceof ValidationError ||
      error instanceof CartLimitError
    ) {
      throw error;
    }
    console.error('[addItemToCart] Error adding item to cart:', {
      userId,
      itemId: input.itemId,
      quantity: input.quantity,
      error: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw new Error('Failed to add item to cart');
  }
}

/**
 * Update cart item quantity
 *
 * Business Rules:
 * - BR-2.2: Quantity per item: min 1, max 999
 *
 * @param userId - User ID (ObjectId or string)
 * @param itemId - Item ID in cart
 * @param quantity - New quantity
 * @returns Updated cart
 */
export async function updateCartItemQuantity(
  userId: string | Types.ObjectId,
  itemId: string,
  quantity: number
): Promise<Cart> {
  await connectDB();

  // Validate quantity (BR-2.2)
  if (quantity < MIN_ITEM_QUANTITY || quantity > MAX_ITEM_QUANTITY) {
    throw new ValidationError(
      `Quantity must be between ${MIN_ITEM_QUANTITY} and ${MAX_ITEM_QUANTITY}`
    );
  }

  try {
    // Convert string userId to ObjectId for MongoDB query
    const userIdQuery = toObjectId(userId);

    const cart = await CartModel.findOne({ userId: userIdQuery }).exec();

    if (!cart) {
      throw new ValidationError('Cart not found');
    }

    const itemIndex = cart.items.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (cartItem: any) => cartItem.itemId?.toString() === itemId
    );

    if (itemIndex === -1) {
      throw new ValidationError('Item not found in cart');
    }

    cart.items[itemIndex].quantity = quantity;
    const updatedCart = await cart.save();

    return mapCartToDto(updatedCart);
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    console.error('Error updating cart item quantity:', error);
    throw new Error('Failed to update cart item quantity');
  }
}

/**
 * Remove item from cart
 *
 * @param userId - User ID (ObjectId or string)
 * @param itemId - Item ID to remove
 * @returns Updated cart
 */
export async function removeCartItem(
  userId: string | Types.ObjectId,
  itemId: string
): Promise<Cart> {
  await connectDB();

  try {
    // Convert string userId to ObjectId for MongoDB query
    const userIdQuery = toObjectId(userId);

    const cart = await CartModel.findOne({ userId: userIdQuery }).exec();

    if (!cart) {
      throw new ValidationError('Cart not found');
    }

    const initialLength = cart.items.length;
    cart.items = cart.items.filter(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (cartItem: any) => cartItem.itemId?.toString() !== itemId
    );

    if (cart.items.length === initialLength) {
      throw new ValidationError('Item not found in cart');
    }

    const updatedCart = await cart.save();
    return mapCartToDto(updatedCart);
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    console.error('Error removing cart item:', error);
    throw new Error('Failed to remove cart item');
  }
}

/**
 * Clear all items from cart
 *
 * Used after successful checkout (BR-2.7)
 *
 * @param userId - User ID (ObjectId or string)
 * @returns Empty cart
 */
export async function clearCart(
  userId: string | Types.ObjectId
): Promise<Cart> {
  await connectDB();

  try {
    // Convert string userId to ObjectId for MongoDB query
    const userIdQuery = toObjectId(userId);

    const cart = await CartModel.findOne({ userId: userIdQuery }).exec();

    if (!cart) {
      // Create empty cart if doesn't exist
      const newCart = new CartModel({
        userId: userIdQuery,
        items: [],
      });
      const savedCart = await newCart.save();
      return mapCartToDto(savedCart);
    }

    cart.items = [];
    const updatedCart = await cart.save();
    return mapCartToDto(updatedCart);
  } catch (error) {
    console.error('Error clearing cart:', error);
    throw new Error('Failed to clear cart');
  }
}

/**
 * Analyze cart statistics
 *
 * Returns useful statistics about the cart items for AI agent queries
 *
 * @param userId - User ID (ObjectId or string)
 * @returns Cart analytics
 */
export async function analyzeCart(userId: string | Types.ObjectId): Promise<{
  itemCount: number;
  uniqueItems: number;
  totalCost: number;
  highestUnitPrice: { itemName: string; price: number } | null;
  lowestUnitPrice: { itemName: string; price: number } | null;
  averageUnitPrice: number;
  mostExpensiveItem: {
    itemName: string;
    subtotal: number;
    quantity: number;
  } | null;
}> {
  await connectDB();

  try {
    const cart = await getCartForUser(userId);

    if (cart.items.length === 0) {
      return {
        itemCount: 0,
        uniqueItems: 0,
        totalCost: 0,
        highestUnitPrice: null,
        lowestUnitPrice: null,
        averageUnitPrice: 0,
        mostExpensiveItem: null,
      };
    }

    // Find highest and lowest unit price
    const sortedByUnitPrice = [...cart.items].sort(
      (a, b) => b.itemPrice - a.itemPrice
    );
    const highestUnitPrice = {
      itemName: sortedByUnitPrice[0].itemName,
      price: sortedByUnitPrice[0].itemPrice,
    };
    const lowestUnitPrice = {
      itemName: sortedByUnitPrice[sortedByUnitPrice.length - 1].itemName,
      price: sortedByUnitPrice[sortedByUnitPrice.length - 1].itemPrice,
    };

    // Find most expensive item by subtotal
    const sortedBySubtotal = [...cart.items].sort(
      (a, b) => b.subtotal - a.subtotal
    );
    const mostExpensiveItem = {
      itemName: sortedBySubtotal[0].itemName,
      subtotal: sortedBySubtotal[0].subtotal,
      quantity: sortedBySubtotal[0].quantity,
    };

    // Calculate average unit price
    const averageUnitPrice =
      cart.items.reduce((sum, item) => sum + item.itemPrice, 0) /
      cart.items.length;

    // Calculate total item count
    const itemCount = cart.items.reduce((sum, item) => sum + item.quantity, 0);

    return {
      itemCount,
      uniqueItems: cart.items.length,
      totalCost: cart.totalCost,
      highestUnitPrice,
      lowestUnitPrice,
      averageUnitPrice,
      mostExpensiveItem,
    };
  } catch (error) {
    console.error('Error analyzing cart:', error);
    throw new Error('Failed to analyze cart');
  }
}

// ============================================================================
// Mapping Helpers
// ============================================================================

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function mapCartToDto(cart: any): Cart {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const items = cart.items.map((item: any) => ({
    itemId: item.itemId?.toString() || '',
    itemName: item.name,
    itemPrice: item.unitPrice,
    quantity: item.quantity,
    subtotal: item.unitPrice * item.quantity,
    addedAt: item.addedAt,
  }));

  const totalCost = items.reduce(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (sum: number, item: any) => sum + item.subtotal,
    0
  );

  return {
    id: cart._id.toString(),
    userId: cart.userId.toString(),
    items,
    totalCost,
    createdAt: cart.createdAt,
    updatedAt: cart.updatedAt,
  };
}
